#include "Player.h"


using namespace std;

int i = -1; //<! Just to count things

Player::Player(){ // TODO: Make that useful

}

template<class maze>
vector<pair<int, int>> Player::find_valid_positions(maze _maze, pair<int, int> spawn){ //TODO: pass by reference
  vector<pair<int, int>> validPositions; //<! Store all the positions generated
  // Se all the possible places around the snake that it can go and stores them in the validPositions vector
  for(int x = -1; x < 2; x++){  // For the lines
   for(int y = -1; y < 2; y++){ // For the columns
     if(    (spawn.first + x < 14 and spawn.second + y < 9)
        and (spawn.first + x > 0  and spawn.second + y > 0)
        and ((*_maze)[spawn.first + x][spawn.second + y] != '#')
        and !(x == 0 and y == 0)){
       validPositions.push_back(make_pair(spawn.first + x, spawn.second + y));
     }
   }
  }

  return validPositions;
}

bool Player::find_solution(Level *level, pair<int, int> spawn){ // TODO: The spawn should be in the level. The solution is already in the player. Not need to pass here both
    // TODO: Put first element as the spawn
  int i = 0; //<! Just a auxiliary in debuggin and testing
  auto maze = level->get_maze(); //<! Get a pointer to the maze
  vector<pair<int, int>> validPositions; //<! To store all the positions generated by find_valid_positions()
  pair<int, int> randomPosition; //<! Just a auxiliary and update the spawn

  do{ // Creates a random solution and stores it in the Player::solution vector
    validPositions = find_valid_positions(maze, spawn);
    randomPosition = validPositions[rand() % validPositions.size()]; //TODO: .size() + 1?
    spawn = randomPosition;
    solution.push_back(randomPosition);
    i++;
  }while(i != 1000); // TODO: Make that ideal for the non tail version
  //} while(validPositions.size() != 0); // This is going to be useful in the tail mode

  return true;
}

pair<int, int> Player::next_move(){
  i++;
  //cout << "I:" << i << endl;
  return solution[i];

}
