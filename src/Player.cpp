#include "Player.h"


using namespace std;

int i = -1; //<! Just to count things

Player::Player(){ // TODO: Make that useful
}

template<class maze>
vector<pair<int, int>> Player::find_valid_positions(maze _maze, pair<int, int> spawn){ //TODO: pass by reference
  vector<pair<int, int>> validPositions; //<! Store all the positions generated
  // Se all the possible places around the snake that it can go and stores them in the validPositions vector
  for(int x = -1; x < 2; x++){  // For the lines
   for(int y = -1; y < 2; y++){ // For the columns
     if(    (spawn.first + x < 14 and spawn.second + y < 9) //TODO: kill that hard code
            and (spawn.first + x > 0  and spawn.second + y > 0)
            and ((*_maze)[spawn.first + x][spawn.second + y] != '#')
            and !(x == 0 and y == 0) // Can't be in the same spot
            and !(x != 0 and y != 0)){ // Can't be in the diagonals
       validPositions.push_back(make_pair(spawn.first + x, spawn.second + y));
     }
   }
  }

  return validPositions;
}

bool Player::find_solution(std::shared_ptr<Level> level){
  // TODO: Put first element as the spawn
  //int i = 0; //<! Just a auxiliary in debuggin and testing
  auto maze = level->get_maze(); //<! Get a pointer to the maze
  vector<pair<int, int>> validPositions; //<! To store all the positions generated by find_valid_positions()
  pair<int, int> randomPosition = level->get_spawn(); //<! Just a auxiliary and update the spawn
  solution.clear();
  i = -1;

  do{ // Creates a random solution and stores it in the Player::solution vector
    validPositions = find_valid_positions(maze, randomPosition);
    randomPosition = validPositions[rand() % validPositions.size()]; //TODO: .size() + 1?
    solution.push_back(randomPosition);
    //i++;
  }while((*maze)[randomPosition.first][randomPosition.second] != '$');

  return true;
}

pair<int, int> Player::next_move(){
  i++;
  //cout << "I:" << i << endl;
  return solution[i];

}
