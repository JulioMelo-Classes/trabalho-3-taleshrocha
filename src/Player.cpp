#include "Player.h"

using namespace std;

void wait(int ms){
    this_thread::sleep_for(chrono::milliseconds(ms));
}

Player::Player(){ // TODO: Make that useful
}

bool Player::find_solution(std::shared_ptr<Level> level, std::shared_ptr<Snake> snake){
  //solution.clear(); // Deletes all old solutions //TODO fix that bugs in here
  moveCounter = -1; // Resets the counter //TODO fix that to
  auto maze = level->get_maze();
  auto body = snake->get_body();
  pair<int, int> lastPos = (*body)[0];
  bool bite = false; // just to auxiliate
  //wait(100);

  if((*maze)[(*body)[0].first][(*body)[0].second] == '$')
    return true;

  //if((*maze)[(*body)[0].first - 1][(*body)[0].second] != '#'
  //   and find(solution.begin(), solution.end(), make_pair((*body)[0].first + 1, (*body)[0].second)) == solution.end()){
  //  cout << "DOWN" << endl;
  //  snake->move(make_pair((*body)[0].first + 1, (*body)[0].second), false);
  //  solution.push_back((*body)[0]);
  //  if(find_solution(level, snake))
  //    return true;
  //}

  for(int x = -1; x < 2; x++){   // for the lines
    for(int y = -1; y < 2; y++){ // for the columns
      if(((*body)[0].first + x < (int) level->get_maze_height() and (*body)[0].second + y < (int) level->get_maze_width()) // can't be outside the maze
         and ((*body)[0].first + x > 0  and (*body)[0].second + y > 0)     // can't be outside the maze
         and ((*maze)[(*body)[0].first + x][(*body)[0].second + y] != '#') // can't be in the wall
         and !(x == 0 and y == 0)                                          // can't be in the same spot
         and !(x != 0 and y != 0)                                          // can't be in the diagonals
         and (find(solution.begin(), solution.end(), make_pair((*body)[0].first + x, (*body)[0].second + y)) == solution.end())
         and !(lastPos.first == (*body)[0].first + x and lastPos.second == (*body)[0].second + y)){ // can't be in the back
        for(int i = 1; i < (int) body->size(); i++){ // see if the snake will not bite it's tail at any spot
          if((*body)[0].first + x == (*body)[i].first and (*body)[0].second + y == (*body)[i].second){
            bite = true;
            break;
          }
        }
        if(!bite){
          cout << x << " " << y << endl;
          lastPos = (*body)[0];
          snake->move(make_pair((*body)[0].first + x, (*body)[0].second + y), false);
          solution.push_back((*body)[0]);
          if(find_solution(level, snake))
            return true;
        }
        bite = false;
      }
    }
  }
  //solution.push_back(make_pair(-1, -1));
  return false;
}

pair<int, int> Player::next_move(){
  moveCounter++;
  return solution[moveCounter];
}

//std::vector<std::pair<int, int>> Player::find_valid_positions(std::shared_ptr<Level> level, std::shared_ptr<Snake> snake, std::pair<int, int> lastPos){
//  vector<pair<int, int>> validpositions; // is where all the valid positions around the snake go
//  bool bite = false; // just to auxiliate
//  auto maze = level->get_maze();
//  auto body = snake->get_body();
//
//
//  // se all the possible places around the snake that it can go and stores them in the validpositions vector
//  for(int x = -1; x < 2; x++){   // for the lines
//    for(int y = -1; y < 2; y++){ // for the columns
//      if(((*body)[0].first + x < (int) level->get_maze_height() and (*body)[0].second + y < (int) level->get_maze_width()) // can't be outside the maze
//         and ((*body)[0].first + x > 0  and (*body)[0].second + y > 0)     // can't be outside the maze
//         and ((*maze)[(*body)[0].first + x][(*body)[0].second + y] != '#') // can't be in the wall
//         and !(x == 0 and y == 0)                                          // can't be in the same spot
//         and !(x != 0 and y != 0)                                          // can't be in the diagonals
//         and !(lastpos.first == (*body)[0].first + x and lastpos.second == (*body)[0].second + y)){ // can't be in the back
//        for(int i = 1; i < (int) body->size(); i++){ // see if the snake will not bite it's tail at any spot
//          if((*body)[0].first + x == (*body)[i].first and (*body)[0].second + y == (*body)[i].second){
//            bite = true;
//            break;
//          }
//        }
//        if(!bite){
//          validpositions.push_back(make_pair((*body)[0].first + x, (*body)[0].second + y));
//        }
//        bite = false;
//      }
//    }
//  }
//
//  return validPositions;
//}

//bool Player::find_solution(std::shared_ptr<Level> level, std::shared_ptr<Snake> snake){
//  solution.clear(); // Deletes all old solutions
//  moveCounter = -1; // Resets the counter
//  vector<pair<int, int>> validPositions; // Store all the save positions generated by find_valid_positions
//  auto maze = level->get_maze();
//  auto body = snake->get_body();
//  pair<int, int> lastPos = (*body)[0];
//
//  // Pics a random position of the validPositions and stores it in the solution vector
//  while((*maze)[(*body)[0].first][(*body)[0].second] != '$'){
//    validPositions = find_valid_positions(level, snake, lastPos);
//    if(!validPositions.size()){
//      solution.push_back(make_pair(-1, -1));
//      return false;
//    }
//    lastPos = (*body)[0];
//    snake->move(validPositions[rand() % validPositions.size()], false);
//    solution.push_back((*body)[0]);
//  }
//
//  return true;
//}
